use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::env;
use std::fs;
use std::path::Path;

// Build-time types for parsing registry YAML files
#[derive(Debug, Deserialize, Serialize, Clone)]
#[serde(rename_all = "snake_case")]
enum PackageType {
    GithubArchive,
    GithubContent,
    GithubRelease,
    Http,
    GoInstall,
    Cargo,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
struct File {
    pub name: String,
    pub src: Option<String>,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
struct Alias {
    pub name: String,
}

#[derive(Debug, Deserialize, Serialize, Clone, Default)]
#[serde(default)]
struct Package {
    pub r#type: Option<PackageType>,
    pub repo_owner: Option<String>,
    pub repo_name: Option<String>,
    pub name: Option<String>,
    pub asset: Option<String>,
    pub url: Option<String>,
    pub description: Option<String>,
    pub format: Option<String>,
    pub rosetta2: Option<bool>,
    pub windows_arm_emulation: Option<bool>,
    pub complete_windows_ext: Option<bool>,
    pub supported_envs: Option<Vec<String>>,
    pub files: Option<Vec<File>>,
    pub replacements: Option<HashMap<String, String>>,
    pub version_prefix: Option<String>,
    pub version_filter: Option<String>,
    pub version_source: Option<String>,
    pub version_constraint: Option<String>,
    pub version_overrides: Option<Vec<Package>>,
    pub no_asset: Option<bool>,
    pub error_message: Option<String>,
    pub path: Option<String>,
    pub aliases: Option<Vec<Alias>>,
    // Skipping complex fields that we don't need for code generation
}

#[derive(Debug, Deserialize, Serialize, Clone)]
struct Registry {
    pub packages: Vec<Package>,
}

fn main() {
    let out_dir = env::var("OUT_DIR").expect("OUT_DIR environment variable must be set");

    // Tell cargo to rerun this build script if the aqua-registry directory changes
    let registry_dir = find_registry_dir()
        .expect("Could not find aqua-registry directory in workspace root. Expected to find it at workspace_root/aqua-registry/");
    println!("cargo:rerun-if-changed={}", registry_dir.display());
    generate_baked_registry(&out_dir, &registry_dir);
}

fn generate_baked_registry(out_dir: &str, registry_dir: &Path) {
    let dest_path = Path::new(out_dir).join("aqua_standard_registry.rs");

    let mut all_registries = HashMap::new();
    collect_and_parse_registries(registry_dir, &mut all_registries)
        .expect("Failed to collect aqua registry files");

    if all_registries.is_empty() {
        panic!(
            "No aqua registry files found in {}/pkgs/",
            registry_dir.display()
        );
    }

    // Generate Rust code with pre-parsed structures
    let mut code = String::new();

    code.push_str("// This file is auto-generated by build.rs\n");
    code.push_str("// It contains pre-parsed aqua registry data to avoid runtime YAML parsing\n\n");

    code.push_str("use crate::types::*;\n\n");

    // Generate the main registry with pre-parsed data
    code.push_str("pub static AQUA_STANDARD_REGISTRY: ::std::sync::LazyLock<::std::collections::HashMap<&'static str, RegistryYaml>> = ::std::sync::LazyLock::new(|| {\n");
    code.push_str("    let mut map = ::std::collections::HashMap::new();\n");

    for (id, registry) in &all_registries {
        code.push_str(&format!("\n    // Registry for {}\n", id));
        code.push_str("    map.insert(\n");
        code.push_str(&format!("        {:?},\n", id));
        code.push_str("        RegistryYaml {\n");
        code.push_str("            packages: vec![\n");

        for package in &registry.packages {
            code.push_str(&generate_package_code(package));
        }

        code.push_str("            ],\n");
        code.push_str("        },\n");
        code.push_str("    );\n");
    }

    code.push_str("\n    map\n");
    code.push_str("});\n");

    fs::write(dest_path, code).expect("Failed to write baked registry file");
}

fn generate_package_code(package: &Package) -> String {
    let mut code = String::new();

    // Use Default and then set only public fields
    code.push_str("                {\n");
    code.push_str("                    let mut pkg = AquaPackage::default();\n");

    // Type field
    code.push_str(&format!(
        "                    pkg.r#type = AquaPackageType::{};\n",
        package
            .r#type
            .as_ref()
            .map(|t| match t {
                PackageType::GithubArchive => "GithubArchive",
                PackageType::GithubContent => "GithubContent",
                PackageType::GithubRelease => "GithubRelease",
                PackageType::Http => "Http",
                PackageType::GoInstall => "GoInstall",
                PackageType::Cargo => "Cargo",
            })
            .unwrap_or("GithubRelease")
    ));

    // String fields
    code.push_str(&format!(
        "                    pkg.repo_owner = {:?}.to_string();\n",
        package.repo_owner.as_deref().unwrap_or("")
    ));
    code.push_str(&format!(
        "                    pkg.repo_name = {:?}.to_string();\n",
        package.repo_name.as_deref().unwrap_or("")
    ));

    // Optional string fields
    if let Some(name) = &package.name {
        code.push_str(&format!(
            "                    pkg.name = Some({:?}.to_string());\n",
            name
        ));
    }

    code.push_str(&format!(
        "                    pkg.asset = {:?}.to_string();\n",
        package.asset.as_deref().unwrap_or("")
    ));
    code.push_str(&format!(
        "                    pkg.url = {:?}.to_string();\n",
        package.url.as_deref().unwrap_or("")
    ));

    if let Some(desc) = &package.description {
        code.push_str(&format!(
            "                    pkg.description = Some({:?}.to_string());\n",
            desc
        ));
    }

    code.push_str(&format!(
        "                    pkg.format = {:?}.to_string();\n",
        package.format.as_deref().unwrap_or("")
    ));

    // Boolean fields
    code.push_str(&format!(
        "                    pkg.rosetta2 = {};\n",
        package.rosetta2.unwrap_or(false)
    ));
    code.push_str(&format!(
        "                    pkg.windows_arm_emulation = {};\n",
        package.windows_arm_emulation.unwrap_or(false)
    ));
    code.push_str(&format!(
        "                    pkg.complete_windows_ext = {};\n",
        package.complete_windows_ext.unwrap_or(true)
    ));

    // Vec fields
    if let Some(envs) = &package.supported_envs {
        if !envs.is_empty() {
            code.push_str("                    pkg.supported_envs = vec![");
            for env in envs {
                code.push_str(&format!("{:?}.to_string(), ", env));
            }
            code.push_str("];\n");
        }
    }

    // Files
    if let Some(files) = &package.files {
        if !files.is_empty() {
            code.push_str("                    pkg.files = vec![\n");
            for file in files {
                code.push_str("                        AquaFile {\n");
                code.push_str(&format!(
                    "                            name: {:?}.to_string(),\n",
                    file.name
                ));
                if let Some(src) = &file.src {
                    code.push_str(&format!(
                        "                            src: Some({:?}.to_string()),\n",
                        src
                    ));
                } else {
                    code.push_str("                            src: None,\n");
                }
                code.push_str("                        },\n");
            }
            code.push_str("                    ];\n");
        }
    }

    // Replacements
    if let Some(replacements) = &package.replacements {
        if !replacements.is_empty() {
            code.push_str(
                "                    pkg.replacements = ::std::collections::HashMap::from([\n",
            );
            for (k, v) in replacements {
                code.push_str(&format!(
                    "                        ({:?}.to_string(), {:?}.to_string()),\n",
                    k, v
                ));
            }
            code.push_str("                    ]);\n");
        }
    }

    // Other public fields
    if let Some(vp) = &package.version_prefix {
        code.push_str(&format!(
            "                    pkg.version_prefix = Some({:?}.to_string());\n",
            vp
        ));
    }

    if let Some(vs) = &package.version_source {
        code.push_str(&format!(
            "                    pkg.version_source = Some({:?}.to_string());\n",
            vs
        ));
    }

    // Complex public fields - set to None/defaults for now
    code.push_str("                    pkg.checksum = None;\n");
    code.push_str("                    pkg.slsa_provenance = None;\n");
    code.push_str("                    pkg.minisign = None;\n");

    code.push_str(&format!(
        "                    pkg.no_asset = {};\n",
        package.no_asset.unwrap_or(false)
    ));

    if let Some(err) = &package.error_message {
        code.push_str(&format!(
            "                    pkg.error_message = Some({:?}.to_string());\n",
            err
        ));
    }

    if let Some(path) = &package.path {
        code.push_str(&format!(
            "                    pkg.path = Some({:?}.to_string());\n",
            path
        ));
    }

    // Return the built package
    code.push_str("                    pkg\n");
    code.push_str("                },\n");
    code
}

fn find_registry_dir() -> Option<std::path::PathBuf> {
    let current_dir = env::current_dir().ok()?;

    // Look for the workspace root by finding a Cargo.toml that contains [workspace]
    let workspace_root = current_dir.ancestors().find(|dir| {
        let cargo_toml = dir.join("Cargo.toml");
        if !cargo_toml.exists() {
            return false;
        }
        // Check if this Cargo.toml defines a workspace
        if let Ok(content) = fs::read_to_string(&cargo_toml) {
            content.contains("[workspace]")
        } else {
            false
        }
    })?;

    let aqua_registry = workspace_root.join("aqua-registry");
    if aqua_registry.exists() {
        return Some(aqua_registry);
    }

    None
}

fn collect_and_parse_registries(
    dir: &Path,
    all_registries: &mut HashMap<String, Registry>,
) -> Result<(), Box<dyn std::error::Error>> {
    if !dir.exists() {
        return Ok(());
    }

    let pkgs_dir = dir.join("pkgs");
    if !pkgs_dir.exists() {
        return Ok(());
    }

    collect_registries_recursive(&pkgs_dir, all_registries, String::new())?;

    // Process aliases after all registries are collected
    let mut alias_map = Vec::new();
    for (id, registry) in all_registries.iter() {
        for package in &registry.packages {
            if let Some(aliases) = &package.aliases {
                for alias in aliases {
                    alias_map.push((alias.name.clone(), id.clone()));
                }
            }
        }
    }

    // Add alias entries
    for (alias_name, original_id) in alias_map {
        if let Some(registry) = all_registries.get(&original_id) {
            all_registries.insert(alias_name, registry.clone());
        }
    }

    Ok(())
}

fn collect_registries_recursive(
    dir: &Path,
    registries: &mut HashMap<String, Registry>,
    prefix: String,
) -> Result<(), Box<dyn std::error::Error>> {
    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();

        if path.is_dir() {
            let dir_name = path.file_name().unwrap().to_string_lossy();
            let new_prefix = if prefix.is_empty() {
                dir_name.to_string()
            } else {
                format!("{}/{}", prefix, dir_name)
            };
            collect_registries_recursive(&path, registries, new_prefix)?;
        } else if path.file_name() == Some(std::ffi::OsStr::new("registry.yaml")) {
            let content = fs::read_to_string(&path)?;
            if let Ok(registry) = serde_yaml::from_str::<Registry>(&content) {
                registries.insert(prefix.clone(), registry);
            }
        }
    }
    Ok(())
}
